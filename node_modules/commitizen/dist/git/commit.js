'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.commit = undefined;

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _gulpGit = require('gulp-git');

var _gulpGit2 = _interopRequireDefault(_gulpGit);

var _gulp = require('gulp');

var _gulp2 = _interopRequireDefault(_gulp);

var _dedent = require('dedent');

var _dedent2 = _interopRequireDefault(_dedent);

var _util = require('../common/util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.commit = commit;

/**
 * Asynchronously git commit at a given path with a message
 */

function commit(sh, repoPath, message, options, done) {

  var alreadyEnded = false;
  var dedentedMessage = (0, _dedent2.default)(message);
  var operatingSystemNormalizedMessage = void 0;
  // On windows we must use an array in gulp-git instead of a string because
  // command line parsing works differently
  if (_os2.default.platform() == "win32") {
    operatingSystemNormalizedMessage = dedentedMessage.split(/\r?\n/);
  } else {
    operatingSystemNormalizedMessage = dedentedMessage;
  }

  // Get a gulp stream based off the config
  _gulp2.default.src(repoPath)

  // Format then commit
  .pipe(_gulpGit2.default.commit(operatingSystemNormalizedMessage, options))

  // Write progress to the screen
  .on('data', function (data) {

    // Ignore this for code coverage since it is only there
    // to make our testing suite pretty
    /* istanbul ignore if  */
    if (!options.quiet) {
      if ((0, _util.isString)(data)) {
        process.stdout.write(data);
      }
    }
  })

  // Handle commit success
  .on('end', function () {
    // TODO: Bug? Done is fired twice :(
    if (!alreadyEnded) {
      done();
      alreadyEnded = true;
    }
  })

  // Handle commit failure
  .on('error', function (err) {
    console.error(err);
    done(err);
  });
}